{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "peaceful-missouri",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-05-18T13:26:55.367244Z",
     "iopub.status.busy": "2021-05-18T13:26:55.366246Z",
     "iopub.status.idle": "2021-05-18T13:26:56.744885Z",
     "shell.execute_reply": "2021-05-18T13:26:56.742933Z",
     "shell.execute_reply.started": "2021-05-18T13:26:55.367244Z"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import tkinter as tk\n",
    "from tkinter import filedialog as fd\n",
    "from tkinter import messagebox\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib.backends.backend_tkagg import (\n",
    "    FigureCanvasTkAgg,\n",
    "    NavigationToolbar2Tk,\n",
    ")\n",
    "from matplotlib.figure import Figure"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "further-accident",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-05-18T13:26:56.746880Z",
     "iopub.status.busy": "2021-05-18T13:26:56.746880Z",
     "iopub.status.idle": "2021-05-18T13:26:56.828662Z",
     "shell.execute_reply": "2021-05-18T13:26:56.821679Z",
     "shell.execute_reply.started": "2021-05-18T13:26:56.746880Z"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "class GaitDataMLP:\n",
    "    def __init__(\n",
    "        self,\n",
    "        layer_dims,\n",
    "        learning_rate,\n",
    "        gait_raw_data=\"Sheet2.dat\",\n",
    "        num_iter_cap=100,\n",
    "        train_test_split=0.8,\n",
    "        polarity=\"bi\",\n",
    "        cost_limit=10 ^ (-6),\n",
    "    ):\n",
    "        self.gait_raw_data = np.loadtxt(gait_raw_data)\n",
    "        self.learning_rate = learning_rate\n",
    "        self.layer_dims = layer_dims\n",
    "        self.num_iter_cap = num_iter_cap\n",
    "        self.cost_limit = cost_limit\n",
    "        self.train_test_split = train_test_split\n",
    "        if polarity == \"uni\" or polarity == \"bi\":\n",
    "            self.polarity = polarity\n",
    "        else:\n",
    "            raise Exception(\n",
    "                \"Polarity can only be unipolar -> 'uni' or bipolar ->'bi'\"\n",
    "            )\n",
    "\n",
    "    def data_preprocessing(self, a):\n",
    "\n",
    "        # Normalization\n",
    "        self.aMin = np.min(a)\n",
    "        self.aMax = np.max(a)\n",
    "\n",
    "        if self.polarity == \"uni\":\n",
    "            aNorm = (a - self.aMin) / (self.aMax - self.aMin)\n",
    "        elif self.polarity == \"bi\":\n",
    "            aNorm = (2 * (a - self.aMin) / (self.aMax - self.aMin)) - 1\n",
    "\n",
    "        self.aNorm = aNorm\n",
    "\n",
    "        # Padding to prevent data loss from windowing, the input data is padded with the repetition of the edge data\n",
    "        aNorm = np.pad(self.aNorm, (self.layer_dims[0], 0), \"edge\")\n",
    "        self.test = aNorm\n",
    "        # Rolling Window\n",
    "        window = self.layer_dims[0] + 1\n",
    "        shape = aNorm.shape[:-1] + (aNorm.shape[-1] - window + 1, window)\n",
    "        strides = aNorm.strides + (aNorm.strides[-1],)\n",
    "\n",
    "        windowed_data = np.lib.stride_tricks.as_strided(\n",
    "            aNorm, shape=shape, strides=strides\n",
    "        )\n",
    "\n",
    "        # Train Test Split\n",
    "\n",
    "        # for training splitting in time series can't be randomized\n",
    "        # it needs to follow the change of data through time\n",
    "\n",
    "        split_index = int(windowed_data.shape[0] * self.train_test_split)\n",
    "\n",
    "        self.x_train = windowed_data[:split_index, :-1].T\n",
    "        self.y_train = windowed_data[:split_index, -1].reshape(1, -1)\n",
    "\n",
    "        self.x_test = windowed_data[split_index:, :-1].T\n",
    "        self.y_test = windowed_data[split_index:, -1].reshape(1, -1)\n",
    "\n",
    "        # Recalling Data\n",
    "        self.in_gait_data = windowed_data[:, :-1].T\n",
    "        self.out_gait_data = windowed_data[:, -1].reshape(1, -1)\n",
    "\n",
    "    def init_param(self):\n",
    "        \"\"\"\n",
    "        Initializing parameter of \"W\"\n",
    "\n",
    "        Input:\n",
    "        layer_dims = list containing the dimensions of each layer in the network\n",
    "\n",
    "        Output:\n",
    "        parameters = dictionary containing the parameters \"W1\", \"b1\", ..., \"WL\", \"bL\":\n",
    "                        Wl  weight matrix of shape (layer_dims[l], layer_dims[l-1])\n",
    "        \"\"\"\n",
    "        self.parameters = {}\n",
    "        L = len(self.layer_dims)  # number of layers in the network\n",
    "\n",
    "        for l in range(1, L):\n",
    "            self.parameters[\"W\" + str(l)] = (\n",
    "                np.random.randn(self.layer_dims[l], self.layer_dims[l - 1])\n",
    "                * 0.001\n",
    "            )\n",
    "            self.parameters[\"b\" + str(l)] = np.zeros((self.layer_dims[l], 1))\n",
    "\n",
    "    def sigmoid(self, Z):\n",
    "\n",
    "        if self.polarity == \"uni\":\n",
    "            A = 1 / (1 + np.exp(-Z))\n",
    "\n",
    "        elif self.polarity == \"bi\":\n",
    "            A = (2 / (1 + np.exp(-Z))) - 1\n",
    "\n",
    "        return A, Z\n",
    "\n",
    "    def linear_forward(self, A, W, b):\n",
    "        \"\"\"\n",
    "        Implement the linear part of a layer's forward propagation.\n",
    "\n",
    "        Input:\n",
    "        A = activations from previous layer (or input data)\n",
    "        W = weights matrix\n",
    "        b = bias vector\n",
    "\n",
    "        Output:\n",
    "        Z = the input of the activation function, also called pre-activation parameter\n",
    "        cache = a python tuple containing \"A\", \"W\" and \"b\" stored for computing the backprop\n",
    "        \"\"\"\n",
    "\n",
    "        Zin = np.dot(np.ascontiguousarray(W), np.ascontiguousarray(A)) - b\n",
    "        cache = (A, W, b)\n",
    "\n",
    "        return Zin, cache\n",
    "\n",
    "    def linear_activation_forward(self, A_prev, W, b):\n",
    "        \"\"\"\n",
    "        Implementing activation function\n",
    "        \"\"\"\n",
    "        Z, linear_cache = self.linear_forward(\n",
    "            np.ascontiguousarray(A_prev),\n",
    "            np.ascontiguousarray(W),\n",
    "            np.ascontiguousarray(b),\n",
    "        )\n",
    "        A, activation_cache = self.sigmoid(Z)\n",
    "        cache = (linear_cache, activation_cache)\n",
    "\n",
    "        return A, cache\n",
    "\n",
    "    def L_model_forward(self, X):\n",
    "        \"\"\"\n",
    "        Forward Propagation in one function\n",
    "\n",
    "        Input:\n",
    "        X = Input matrix\n",
    "        parameters = dictionary containing all the 'W' and 'b' necessary for computing\n",
    "        \"\"\"\n",
    "\n",
    "        self.caches = []\n",
    "        A = X\n",
    "        L = len(self.parameters) // 2\n",
    "\n",
    "        for l in range(1, L + 1):\n",
    "            A_prev = A\n",
    "            A, cache = self.linear_activation_forward(\n",
    "                A_prev,\n",
    "                self.parameters[\"W\" + str(l)],\n",
    "                self.parameters[\"b\" + str(l)],\n",
    "            )\n",
    "            self.caches.append(cache)\n",
    "        return A\n",
    "\n",
    "    def compute_cost(self, A, Y):\n",
    "        cost = np.sum(np.square(Y - A), axis=1) / len(A.T)\n",
    "        return cost\n",
    "\n",
    "    def sigmoid_inv(self, v):\n",
    "        \"\"\"\n",
    "        Derivation of sigmoid function to help backward propagation\n",
    "\n",
    "        Input:\n",
    "        v = Activation vector cache\n",
    "\n",
    "        Output:\n",
    "        g = Gradient\n",
    "        \"\"\"\n",
    "        A, Z = self.sigmoid(v)\n",
    "        if self.polarity == \"uni\":\n",
    "            g = A * (1 - A)\n",
    "        elif self.polarity == \"bi\":\n",
    "            g = (1 - A ** 2) / 2\n",
    "\n",
    "        return g\n",
    "\n",
    "    def L_model_backward(self, A, Y):\n",
    "        \"\"\"\n",
    "        In this process, the cache of forward propagation will be used to calculate delta for the parameter update\n",
    "\n",
    "        Input:\n",
    "        A= Model Output\n",
    "        Y= Desired Output\n",
    "        caches = List of cache (Linear Activation)\n",
    "\n",
    "        Output:\n",
    "        d_cache = dictionary of delta for each layer\n",
    "        \"\"\"\n",
    "        L = len(self.caches)\n",
    "        self.d_cache = {}\n",
    "        \"\"\"\n",
    "        Outer Layer Delta Computation\n",
    "        \"\"\"\n",
    "        d_outer = (Y - A) * self.sigmoid_inv(self.caches[L - 1][1])\n",
    "        d = d_outer\n",
    "        self.d_cache[\"d\" + str(L)] = d\n",
    "        \"\"\"\n",
    "        n Layer Delta Computation\n",
    "        \"\"\"\n",
    "        for l in reversed(range(L - 1)):\n",
    "            d_prev = d\n",
    "            d = np.dot(self.caches[l + 1][0][1].T, d_prev) * self.sigmoid_inv(\n",
    "                self.caches[l][1]\n",
    "            )\n",
    "            self.d_cache[\"d\" + str(l + 1)] = d\n",
    "\n",
    "    def update_param(self):\n",
    "        # Due to the limitation of python for loop performance, numpy array is used instead\n",
    "        # the updating equation is the same, the difference is there is no iteration for each delta and x\n",
    "        # and it is replaced by 3d matrix scalar multiplication\n",
    "\n",
    "        L = len(self.parameters) // 2\n",
    "        for l in range(1, L + 1):\n",
    "\n",
    "            d_array = self.d_cache[\"d\" + str(l)][:, None]\n",
    "            x_array = self.caches[l - 1][0][0][:, None].transpose(1, 0, 2)\n",
    "            d_x_mul = np.multiply(d_array, x_array)\n",
    "            d_x_array = np.sum(d_x_mul, axis=2)\n",
    "\n",
    "            self.parameters[\"W\" + str(l)] += self.learning_rate * d_x_array\n",
    "\n",
    "            self.parameters[\"b\" + str(l)] -= self.learning_rate * np.sum(\n",
    "                d_array, axis=2\n",
    "            )\n",
    "\n",
    "    def data_postprocessing(self, A):\n",
    "        # Inversing the process of normalization\n",
    "        if self.polarity == \"uni\":\n",
    "            aInv = A * (self.aMax - self.aMin) + self.aMin\n",
    "        elif self.polarity == \"bi\":\n",
    "            aInv = ((A + 1) * (self.aMax - self.aMin) / 2) + self.aMin\n",
    "\n",
    "        return aInv\n",
    "\n",
    "    def train(self):\n",
    "\n",
    "        self.data_preprocessing(self.gait_raw_data)\n",
    "\n",
    "        self.init_param()\n",
    "\n",
    "        self.cost_epoch = []\n",
    "        self.cost_test_epoch = []\n",
    "        self.iter_optimize = 0\n",
    "\n",
    "        while True:\n",
    "            self.iter_optimize += 1\n",
    "            A_train = self.L_model_forward(self.x_train)\n",
    "\n",
    "            self.cost_train = self.compute_cost(A_train, self.y_train)\n",
    "            self.cost_epoch.append(self.cost_train)\n",
    "\n",
    "            if (\n",
    "                self.cost_train < self.cost_limit\n",
    "                or self.iter_optimize > self.num_iter_cap - 1\n",
    "            ):\n",
    "                break\n",
    "\n",
    "            self.L_model_backward(A_train, self.y_train)\n",
    "\n",
    "            self.update_param()\n",
    "\n",
    "            A_test = self.L_model_forward(self.x_test)\n",
    "\n",
    "            self.cost_test = self.compute_cost(A_test, self.y_test)\n",
    "            self.cost_test_epoch.append(self.cost_test)\n",
    "\n",
    "    #             if self.iter_optimize % 100 == 0:\n",
    "    #                 print(self.iter_optimize)\n",
    "\n",
    "    def recall(self):\n",
    "        # in_gait_data is the raw data that had been preprocessed\n",
    "        A_recall = self.L_model_forward(self.in_gait_data)\n",
    "        A_post = self.data_postprocessing(A_recall)\n",
    "        self.cost_recall = self.compute_cost(A_recall, self.out_gait_data)\n",
    "        return A_post"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "fc2ecbb5-1edc-40d4-8ddb-03aec30444da",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-05-18T13:26:56.833649Z",
     "iopub.status.busy": "2021-05-18T13:26:56.832653Z",
     "iopub.status.idle": "2021-05-18T13:26:56.947853Z",
     "shell.execute_reply": "2021-05-18T13:26:56.946856Z",
     "shell.execute_reply.started": "2021-05-18T13:26:56.833649Z"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "class GUI:\n",
    "    def __init__(self):\n",
    "        self.inputfile = \" \"\n",
    "        self.window = tk.Tk()\n",
    "        self.window.state(\"normal\")\n",
    "        self.window.title(\n",
    "            \"Gait Data Prediction System using MLP and EBPA - Aditya Wardianto 07311940000001\"\n",
    "        )\n",
    "\n",
    "        # Frame\n",
    "        self.frm_input = tk.Frame()\n",
    "        frm_input = self.frm_input\n",
    "\n",
    "        self.cost_texttrain = tk.StringVar()\n",
    "        self.cost_texttrain.set(\"Train Error = \")\n",
    "\n",
    "        self.cost_texttest = tk.StringVar()\n",
    "        self.cost_texttest.set(\"Test Error = \")\n",
    "\n",
    "        self.iter_text = tk.StringVar()\n",
    "        self.iter_text.set(\"Iteration = \")\n",
    "\n",
    "        self.cost_textrecall = tk.StringVar()\n",
    "        self.cost_textrecall.set(\"Recall Error = \")\n",
    "\n",
    "        # Label\n",
    "        lbl_nin = tk.Label(text=\"Number of Input Node\", master=frm_input)\n",
    "        lbl_nhidden = tk.Label(\n",
    "            text=\"Number of Node in                 \\nHidden Layer (L1 L2 L3 ... LN)\",\n",
    "            master=frm_input,\n",
    "        )\n",
    "        lbl_nout = tk.Label(text=\"Number of Output Node\", master=frm_input)\n",
    "        lbl_iter_cap = tk.Label(\n",
    "            text=\"Number of Iteration Limit\", master=frm_input\n",
    "        )\n",
    "        lbl_lrate = tk.Label(text=\"Learning Rate\", master=frm_input)\n",
    "        lbl_split = tk.Label(\n",
    "            text=\"Train Test Split (In decimal)\", master=frm_input\n",
    "        )\n",
    "        self.lbl_costtrain = tk.Label(\n",
    "            master=frm_input, textvariable=self.cost_texttrain\n",
    "        )\n",
    "        self.lbl_costtest = tk.Label(\n",
    "            master=frm_input, textvariable=self.cost_texttest\n",
    "        )\n",
    "        self.lbl_costrecall = tk.Label(\n",
    "            master=frm_input, textvariable=self.cost_textrecall\n",
    "        )\n",
    "        self.lbl_iter_opt = tk.Label(\n",
    "            master=frm_input, textvariable=self.iter_text\n",
    "        )\n",
    "\n",
    "        one = tk.StringVar()\n",
    "        one.set(\"1\")\n",
    "        pred_text = tk.StringVar()\n",
    "        pred_text.set(\"Prediction\")\n",
    "\n",
    "        a = tk.StringVar()\n",
    "        a.set(\"10\")\n",
    "        b = tk.StringVar()\n",
    "        b.set(\"5\")\n",
    "        c = tk.StringVar()\n",
    "        c.set(\"50000\")\n",
    "        d = tk.StringVar()\n",
    "        d.set(\"0.0002\")\n",
    "        e = tk.StringVar()\n",
    "        e.set(\"0.8\")\n",
    "\n",
    "        # Entry\n",
    "        self.ent_nin = tk.Entry(master=frm_input, textvariable=a)\n",
    "        self.ent_nhidden = tk.Entry(master=frm_input, textvariable=b)\n",
    "        ent_nout = tk.Entry(\n",
    "            master=frm_input, textvariable=one, state=\"disable\"\n",
    "        )\n",
    "        self.ent_iter_cap = tk.Entry(master=frm_input, textvariable=c)\n",
    "        self.ent_lrate = tk.Entry(master=frm_input, textvariable=d)\n",
    "        self.ent_split = tk.Entry(master=frm_input, textvariable=e)\n",
    "\n",
    "        # Button\n",
    "        btn_file = tk.Button(\n",
    "            text=\"Input File\", master=frm_input, command=self.input_file\n",
    "        )\n",
    "        btn_Learn = tk.Button(\n",
    "            text=\"Train (Takes Time)\", master=frm_input, command=self.train\n",
    "        )\n",
    "        btn_Pred = tk.Button(\n",
    "            text=\"Recall\", master=frm_input, command=self.recall\n",
    "        )\n",
    "\n",
    "        # Radio\n",
    "        self.polar = tk.StringVar()\n",
    "        self.polar.set(\"uni\")\n",
    "        R1 = tk.Radiobutton(\n",
    "            master=frm_input,\n",
    "            text=\"Unipolar\",\n",
    "            variable=self.polar,\n",
    "            value=\"uni\",\n",
    "        )\n",
    "\n",
    "        R2 = tk.Radiobutton(\n",
    "            master=frm_input, text=\"Bipolar\", variable=self.polar, value=\"bi\",\n",
    "        )\n",
    "\n",
    "        # Packing\n",
    "        btn_file.pack(anchor=tk.W)\n",
    "        lbl_nin.pack(anchor=tk.W)\n",
    "        self.ent_nin.pack(anchor=tk.W)\n",
    "        lbl_nhidden.pack(anchor=tk.W)\n",
    "        self.ent_nhidden.pack(anchor=tk.W)\n",
    "        lbl_nout.pack(anchor=tk.W)\n",
    "        ent_nout.pack(anchor=tk.W)\n",
    "\n",
    "        lbl_iter_cap.pack(anchor=tk.W)\n",
    "        self.ent_iter_cap.pack(anchor=tk.W)\n",
    "        lbl_lrate.pack(anchor=tk.W)\n",
    "        self.ent_lrate.pack(anchor=tk.W)\n",
    "        lbl_split.pack(anchor=tk.W)\n",
    "        self.ent_split.pack(anchor=tk.W)\n",
    "\n",
    "        R1.pack(anchor=tk.W)\n",
    "        R2.pack(anchor=tk.W)\n",
    "\n",
    "        btn_Learn.pack(anchor=tk.W, pady=5)\n",
    "        self.lbl_costtrain.pack(anchor=tk.W, pady=5)\n",
    "        self.lbl_costtest.pack(anchor=tk.W, pady=5)\n",
    "        self.lbl_iter_opt.pack(anchor=tk.W, pady=5)\n",
    "\n",
    "        btn_Pred.pack(anchor=tk.W, pady=5)\n",
    "        self.lbl_costrecall.pack(anchor=tk.W, pady=5)\n",
    "\n",
    "        frm_input.grid(row=0, column=1, padx=5, pady=5, sticky=\"N\")\n",
    "\n",
    "        self.window.mainloop()\n",
    "\n",
    "    def input_file(self):\n",
    "\n",
    "        filetypes = [(\"All Files\", \"*\")]\n",
    "\n",
    "        self.inputfile = fd.askopenfilename(\n",
    "            title=\"Open a file\", initialdir=\"/\", filetypes=filetypes\n",
    "        )\n",
    "\n",
    "    def input_data(self):\n",
    "        \"\"\"\n",
    "        Getting input for training from GUI\n",
    "\n",
    "        Output:\n",
    "\n",
    "        \"\"\"\n",
    "        try:\n",
    "            if (\n",
    "                int(self.ent_nin.get()) == 0\n",
    "                or int(self.ent_iter_cap.get()) == 0\n",
    "                or float(self.ent_lrate.get()) == 0\n",
    "                or float(self.ent_split.get()) == 0\n",
    "            ):\n",
    "                messagebox.showerror(\"Input is not valid\", \"Input > 0\")\n",
    "                return 0\n",
    "            else:\n",
    "\n",
    "                self.layer_dims = [\n",
    "                    int(s)\n",
    "                    for s in self.ent_nhidden.get().split()\n",
    "                    if s.isdigit()\n",
    "                ]\n",
    "\n",
    "                self.layer_dims.insert(0, int(self.ent_nin.get()))\n",
    "\n",
    "                self.layer_dims.append(1)\n",
    "\n",
    "                self.learning_rate = float(self.ent_lrate.get())\n",
    "                self.num_iter_cap = int(self.ent_iter_cap.get())\n",
    "                self.train_test_split = float(self.ent_split.get())\n",
    "                self.polarity = self.polar.get()\n",
    "\n",
    "        except BaseException:\n",
    "            messagebox.showerror(\"Input is not valid\", \"Input Real\")\n",
    "\n",
    "    def train(self):\n",
    "        if self.inputfile != \" \":\n",
    "            gait_raw_data = self.inputfile\n",
    "            self.input_data()\n",
    "\n",
    "            self.model = GaitDataMLP(\n",
    "                layer_dims=self.layer_dims,\n",
    "                gait_raw_data=gait_raw_data,\n",
    "                num_iter_cap=self.num_iter_cap,\n",
    "                train_test_split=self.train_test_split,\n",
    "                learning_rate=self.learning_rate,\n",
    "                polarity=self.polarity,\n",
    "            )\n",
    "\n",
    "            self.model.train()\n",
    "\n",
    "            self.cost_texttrain.set(\n",
    "                \"Train Error = \" + str(self.model.cost_train[0])\n",
    "            )\n",
    "            self.cost_texttest.set(\n",
    "                \"Test Error = \" + str(self.model.cost_test[0])\n",
    "            )\n",
    "            self.iter_text.set(\"Iteration = \" + str(self.model.iter_optimize))\n",
    "\n",
    "            self.cost_textrecall.set(\"Recall Error = \")\n",
    "\n",
    "            fig = Figure(figsize=(19.5, 11), dpi=60, constrained_layout=True)\n",
    "            gs = fig.add_gridspec(ncols=3, nrows=2, hspace=0.5, wspace=0.1)\n",
    "\n",
    "            y_plot = np.array(\n",
    "                [\n",
    "                    [\n",
    "                        self.model.gait_raw_data,\n",
    "                        self.model.aNorm,\n",
    "                        self.model.x_train[0],\n",
    "                    ],\n",
    "                    [self.model.cost_epoch, self.model.cost_test_epoch],\n",
    "                ],\n",
    "                dtype=object,\n",
    "            )\n",
    "\n",
    "            title_list = np.array(\n",
    "                [\n",
    "                    [\"Raw Data\", \"Normalized Data\", \"Train Set\"],\n",
    "                    [\"Train and Test Cost Epoch\"],\n",
    "                ],\n",
    "                dtype=object,\n",
    "            )\n",
    "\n",
    "            for row in range(2):\n",
    "                for col in range(3):\n",
    "                    if row == 0:\n",
    "                        ax = fig.add_subplot(gs[row, col])\n",
    "                        ax.set_title(\n",
    "                            title_list[row][col], fontweight=\"bold\", size=15\n",
    "                        )\n",
    "                        ax.set_xlabel(\"Time\", size=12)\n",
    "                        ax.set_ylabel(\"Value\", size=12)\n",
    "                        ax.plot(range(len(y_plot[row][col])), y_plot[row][col])\n",
    "                    if row == 1 and col == 0:\n",
    "                        ax = fig.add_subplot(gs[row, col])\n",
    "                        ax.set_title(\n",
    "                            title_list[row][col], fontweight=\"bold\", size=15\n",
    "                        )\n",
    "                        ax.set_xlabel(\"Iteration\", size=12)\n",
    "                        ax.set_ylabel(\"Value\", size=12)\n",
    "                        ax.plot(\n",
    "                            range(len(y_plot[row][col])),\n",
    "                            y_plot[row][col],\n",
    "                            label=\"Train Error\",\n",
    "                        )\n",
    "                        ax.plot(\n",
    "                            range(len(y_plot[row][col + 1])),\n",
    "                            y_plot[row][col + 1],\n",
    "                            label=\"Test Error\",\n",
    "                        )\n",
    "                        ax.legend()\n",
    "\n",
    "            canvas = FigureCanvasTkAgg(fig, master=self.window)\n",
    "            canvas.draw()\n",
    "            canvas.get_tk_widget().grid(row=0, column=0, padx=5, pady=5)\n",
    "            toolbarFrame = tk.Frame(master=self.window)\n",
    "            toolbarFrame.grid(row=1, column=0, padx=5, pady=5)\n",
    "            toolbar = NavigationToolbar2Tk(canvas, toolbarFrame)\n",
    "\n",
    "        else:\n",
    "            messagebox.showerror(\"No File\", \"Input File\")\n",
    "\n",
    "    def recall(self):\n",
    "        try:\n",
    "            y_recall = self.model.recall()\n",
    "            self.cost_textrecall.set(\n",
    "                \"Recall Error = \" + str(self.model.cost_recall[0])\n",
    "            )\n",
    "\n",
    "            fig = Figure(figsize=(19.5, 11), dpi=60, constrained_layout=True)\n",
    "            gs = fig.add_gridspec(ncols=3, nrows=2, hspace=0.5, wspace=0.1)\n",
    "\n",
    "            y_plot = np.array(\n",
    "                [\n",
    "                    [\n",
    "                        self.model.gait_raw_data,\n",
    "                        self.model.aNorm,\n",
    "                        self.model.x_train[0],\n",
    "                    ],\n",
    "                    [\n",
    "                        self.model.cost_epoch,\n",
    "                        self.model.cost_test_epoch,\n",
    "                        self.model.gait_raw_data,\n",
    "                        y_recall[0],\n",
    "                    ],\n",
    "                ],\n",
    "                dtype=object,\n",
    "            )\n",
    "\n",
    "            title_list = np.array(\n",
    "                [\n",
    "                    [\"Raw Data\", \"Normalized Data\", \"Train Set\"],\n",
    "                    [\"Train and Test Cost Epoch\", \"Recall Input and Output\"],\n",
    "                ],\n",
    "                dtype=object,\n",
    "            )\n",
    "\n",
    "            for row in range(2):\n",
    "                for col in range(3):\n",
    "                    if row == 0:\n",
    "                        ax = fig.add_subplot(gs[row, col])\n",
    "                        ax.set_title(\n",
    "                            title_list[row][col], fontweight=\"bold\", size=15\n",
    "                        )\n",
    "                        ax.set_xlabel(\"Time\", size=12)\n",
    "                        ax.set_ylabel(\"Value\", size=12)\n",
    "                        ax.plot(range(len(y_plot[row][col])), y_plot[row][col])\n",
    "                    if row == 1 and col == 0:\n",
    "                        ax = fig.add_subplot(gs[row, col])\n",
    "                        ax.set_title(\n",
    "                            title_list[row][col], fontweight=\"bold\", size=15\n",
    "                        )\n",
    "                        ax.set_xlabel(\"Iteration\", size=12)\n",
    "                        ax.set_ylabel(\"Value\", size=12)\n",
    "                        ax.plot(\n",
    "                            range(len(y_plot[row][col])),\n",
    "                            y_plot[row][col],\n",
    "                            label=\"Train Error\",\n",
    "                        )\n",
    "                        ax.plot(\n",
    "                            range(len(y_plot[row][col + 1])),\n",
    "                            y_plot[row][col + 1],\n",
    "                            label=\"Test Error\",\n",
    "                        )\n",
    "                        ax.legend()\n",
    "                    if row == 1 and col == 2:\n",
    "                        ax = fig.add_subplot(gs[row, col - 1])\n",
    "                        ax.set_title(\n",
    "                            title_list[row][col - 1],\n",
    "                            fontweight=\"bold\",\n",
    "                            size=15,\n",
    "                        )\n",
    "                        ax.set_xlabel(\"Time\", size=12)\n",
    "                        ax.set_ylabel(\"Value\", size=12)\n",
    "                        ax.plot(\n",
    "                            range(len(y_plot[row][col])),\n",
    "                            y_plot[row][col],\n",
    "                            label=\"Input Data\",\n",
    "                        )\n",
    "                        ax.plot(\n",
    "                            range(len(y_plot[row][col + 1])),\n",
    "                            y_plot[row][col + 1],\n",
    "                            label=\"Predicted Output Data\",\n",
    "                        )\n",
    "                        ax.legend()\n",
    "\n",
    "            canvas = FigureCanvasTkAgg(fig, master=self.window)\n",
    "            canvas.draw()\n",
    "            canvas.get_tk_widget().grid(row=0, column=0, padx=5, pady=5)\n",
    "            toolbarFrame = tk.Frame(master=self.window)\n",
    "            toolbarFrame.grid(row=1, column=0, padx=5, pady=5)\n",
    "            toolbar = NavigationToolbar2Tk(canvas, toolbarFrame)\n",
    "\n",
    "        except BaseException:\n",
    "            messagebox.showerror(\n",
    "                \"No Trained Model\", \"Train the Model before Recall\"\n",
    "            )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "d6909ba7-28c4-4971-9015-0a8061a5bb31",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-05-18T13:26:56.949848Z",
     "iopub.status.busy": "2021-05-18T13:26:56.948851Z",
     "iopub.status.idle": "2021-05-18T13:27:02.945822Z",
     "shell.execute_reply": "2021-05-18T13:27:02.941832Z",
     "shell.execute_reply.started": "2021-05-18T13:26:56.949848Z"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "if __name__ == \"__main__\":\n",
    "    app = GUI()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9bc9bf74-e8ca-4924-b00f-45dddafb6520",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
